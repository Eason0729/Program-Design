import java.io.*;import java.util.HashMap;import java.io.Reader;import java.util.ArrayList;import java.util.ArrayList;import java.util.ArrayList;import java.text.CharacterIterator;import java.text.StringCharacterIterator;import java.util.ArrayList;import java.util.Iterator;import java.util.regex.Pattern;import java.io.IOException;import java.io.Reader;import java.io.StringReader;import java.text.CharacterIterator;import java.io.Reader;import java.text.CharacterIterator;import java.text.StringCharacterIterator;import java.util.LinkedList;import java.util.Queue;import java.util.regex.Matcher;import java.util.ArrayList; class CodeGenerator {    private final HashMap<String, TypeDeclare> classes = new HashMap<>();    PeekableTokenizer tokenizer;    public CodeGenerator(String[] args) {        this.tokenizer = new PeekableTokenizer(getReader(args));    }    private void insert(PropertyEntry entry){        String typeName=entry.typeName.token;        if(!classes.containsKey(typeName)) classes.put(typeName,new TypeDeclare(typeName));        classes.get(typeName).addProperty(entry.prop);    }    private void insert(TypeDeclare declare){        String typeName=declare.typeName.token;        if(classes.containsKey(typeName))classes.get(typeName).merge(declare.properties);        else classes.put(typeName,declare);    }    private static Reader getReader(String[] args) {        if (args.length == 0) {            System.err.println("請輸入檔案名稱");            System.exit(0);            return null;        }        String fileName = args[0];        System.out.println("File name: " + fileName);        try {            return new BufferedReader(new FileReader(fileName));        } catch (IOException e) {            System.err.println("無法讀取文件 " + fileName);            System.exit(0);            return null;        }    }    public void parse() throws Exception {        Diagram diagram = new Diagram(tokenizer);        for (Statment stat : diagram.statments) {            if (stat.isTypeDeclare()) this.insert(stat.typeDeclare);            if (stat.isPropertyEntry())this.insert(stat.propertyEntry);        }    }    public void generate() throws Exception {        for (TypeDeclare typeDeclare : classes.values()) {            String typeName = typeDeclare.typeName.token;            File file = new File(typeName + ".java");            if (!file.exists()) file.createNewFile();            FileWriter writer = new FileWriter(file);            writer.write(typeDeclare.export());            writer.close();        }    }    public static void main(String[] args) throws Exception {        CodeGenerator generator = new CodeGenerator(args);        generator.parse();        generator.generate();    }} class PeekableTokenizer {    private final ArrayList<Ident> next = new ArrayList<>();    private Tokenizer scan;    public PeekableTokenizer(String source) {        scan = new Tokenizer(source);    }    public PeekableTokenizer(Reader reader) {        scan = new Tokenizer(reader);    }    private void retrieveOne() {        Ident token = scan.next();        if (token == null) scan = null;        else next.add(token);    }    public Ident next() {        if (next.isEmpty()) {            if (scan == null) return null;            this.retrieveOne();            return this.next();        }        Ident current = next.get(0);        next.remove(0);        return current;    }    public boolean hasNext() {        return this.peek() != null;    }    /**     * peek next {@code Ident}     *     * @return indentation     */    public Ident peek() {        return this.peek(0);    }    /**     * peek next {@code size} {@code Ident}     *     * @param size amount of ident to skip     * @return indentation     */    public Ident peek(int size) {        while (next.size() < size + 1) {            if (scan == null) return null;            this.retrieveOne();        }        return next.get(size);    }}/** * Class Diagram * <br> * {@code ClassDiagram {Statment}...} */ class Diagram {    public ArrayList<Statment> statments = new ArrayList<>();    public Diagram(PeekableTokenizer tokenizer) throws Exception {        Ident token = tokenizer.next();        if (!token.token.equals("classDiagram"))            throw token.throwError(String.format("Error: expect \"classDiagram\", found %s", token.token));        while (tokenizer.hasNext()) statments.add(new Statment(tokenizer));    }}/** * Property Entry * <br> * {@code typeName : {Property}} */ class PropertyEntry {    public Ident typeName;    public Property prop;    public PropertyEntry(PeekableTokenizer tokenizer) throws Exception {        this.typeName = tokenizer.next();        this.typeName.errReserved("typeName");        Ident token = tokenizer.next();        if (!token.token.equals(":"))            throw token.throwError(String.format("Error: except keyword \":\", found %s", token.token));        this.prop = new Property((tokenizer));    }}/** * Statment * <br> * {@code {TypeDeclare|propertyEntry}} */ class Statment {    public TypeDeclare typeDeclare = null;    public PropertyEntry propertyEntry = null;    public Statment(PeekableTokenizer tokenizer) throws Exception {        if (tokenizer.peek().token.equals("class")) this.typeDeclare = new TypeDeclare((tokenizer));        else if (tokenizer.peek(1).token.equals(":")) this.propertyEntry = new PropertyEntry(tokenizer);    }    public boolean isTypeDeclare() {        return this.typeDeclare != null;    }    public boolean isPropertyEntry() {        return this.propertyEntry != null;    }}/** * TypeDeclaration * <br> */ class TypeDeclare implements Exportable {    public Ident typeName;    public ArrayList<Property> properties = new ArrayList<>();    /**     * construct new TypeDeclare with fake token     * @param typeName name     */    public TypeDeclare(String typeName) {        this.typeName=new Ident(typeName);    }    public TypeDeclare(PeekableTokenizer tokenizer) throws Exception {        Ident token = tokenizer.next();        if (!token.token.equals("class"))            throw token.throwError(String.format("Error: expect keyword \"class\", found \"%s\"", token.token));        this.typeName = tokenizer.next();        this.typeName.errReserved("typeName");        if (tokenizer.hasNext() && tokenizer.peek().token.equals("{")) {            tokenizer.next();            while (!tokenizer.peek().token.equals("}")) this.properties.add(new Property((tokenizer)));            tokenizer.next();        }    }    public void addProperty(Property prop) {        this.properties.add(prop);    }    public void merge(ArrayList<Property> props) {        this.properties.addAll(props);    }    public String export() throws Exception {        StringBuilder propExport = new StringBuilder();        for (Property prop : properties) propExport.append("\n    ").append(prop.export().replaceAll("\n", "\n    "));        return String.format("public class %s {%s\n}", typeName.token, propExport);    }} class Main {    public static void main(String[] args) throws Exception {        CodeGenerator.main(args);    }} interface Exportable {    public String export() throws Exception;}/** * Indentation, which contain info about span and token */ class Ident extends Span {    public String token = "";    public Ident(int lineNo, int start, String token) {        super(lineNo, start);        this.token = token;    }    public Ident(Span span, String token) {        super(span.lineNo, span.start);        this.token = token;    }    public Ident(String token) {        this.token = token;    }    public Exception throwError(String msg) {        return new Exception(String.format("%s at %s", msg, this.getLocation()));    }    public boolean isReserved() {        CharacterIterator[] progress = Tokenizer.delimiters;        for (CharacterIterator iter : progress) {            if ((iter.getEndIndex() + 1) != token.length()) continue;            CharacterIterator ident = new StringCharacterIterator(this.token);            while (iter.current() == ident.current()) {                iter.next();                ident.next();            }            if (iter.current() == CharacterIterator.DONE) return true;        }        return false;    }    public void errReserved(String msg) throws Exception {        if (this.isReserved()) {            throw this.throwError(String.format("Error: expect \"%s\", found \"%s\"(keyword)", msg, this.token));        }    }}/** * Property * <br> * {@code vis {Value|Method}} */ class Property implements Exportable {    public Visibility vis;    public Value value = null;    public Method method = null;    public Property(PeekableTokenizer tokenizer) throws Exception {        Ident vis = tokenizer.next();        switch (vis.token.charAt(0)) {            case '+' -> this.vis = Visibility.Public;            case '-' -> this.vis = Visibility.Private;            default -> throw vis.throwError("Error: expect visibility(+,-)");        }        if (tokenizer.peek(1).token.equals("(")) this.method = new Method(tokenizer);        else this.value = new Value(tokenizer);    }    public boolean isMethod() {        return method != null;    }    public boolean isValue() {        return value != null;    }    public String export() throws Exception {        String visExport = switch (vis) {            case Public -> "public";            case Private -> "private";        };        if (this.isMethod()) return String.format("%s %s", visExport, this.method.export());        if (this.isValue()) return String.format("%s %s;", visExport, this.value.export());        throw new Exception("unsupported");    }}/** * Argument of function * <br> * {@code argName argType} */ class Argument implements Exportable {    Ident argName;    Ident argType;    public Argument(PeekableTokenizer tokenizer) throws Exception {        this.argType = tokenizer.next();        this.argName = tokenizer.next();        this.argName.errReserved("argName");        this.argType.errReserved("argType");    }    public String export() {        return String.format("%s %s", this.argType.token, this.argName.token);    }}/** * Method * <br> * {@code fnName({Argument}) retType} */ class Method implements Exportable {    public Ident fnName;    public ArrayList<Argument> arguments = new ArrayList<>();    public Ident retType = new Ident("void");    public Method(PeekableTokenizer tokenizer) throws Exception {        this.fnName = tokenizer.next();        this.fnName.errReserved("fnName");        if (!tokenizer.next().token.equals("("))            throw this.fnName.throwError("Error: expect \"(\" at start of method arguments");        try {            while (!tokenizer.peek().token.equals(")"))                if (!tokenizer.peek().token.equals(",")) this.arguments.add(new Argument(tokenizer));                else tokenizer.next();        } catch (NullPointerException err) {            throw this.fnName.throwError("Error: expect \")\" at end of method arguments");        } finally {            tokenizer.next();        }        if (tokenizer.peek(1) != null)            if (tokenizer.peek().token.equals("+")||                    tokenizer.peek().token.equals("-") ||                    tokenizer.peek().token.equals("class") ||                    tokenizer.peek(1).token.equals(":") ||                    tokenizer.peek(1).token.equals("<|--")            ) return;        if (!tokenizer.hasNext()) return;        this.retType = tokenizer.next();        this.retType.errReserved("retType");    }    private String exportArguments() {        StringBuilder argExport = new StringBuilder();        Iterator<Argument> arguments = this.arguments.iterator();        while (arguments.hasNext()) {            Argument arg = arguments.next();            argExport.append(arg.export());            if (arguments.hasNext()) argExport.append(", ");        }        return argExport.toString();    }    /**     * get FnName with prefix removed in lower camel format     *     * @param prefix prefix to remove     * @return processed FnName     */    private String getCamelFnName(String prefix) {        String token = fnName.token.substring(prefix.length());        return Character.toLowerCase(token.charAt(0)) + token.substring(1);    }    /**     * export ItemFn as java     * <br>     * see <a href="https://docs.rs/syn/latest/syn/struct.ItemFn.html">syn</a> in Rust     *     * @return unidentified string     */    private String exportItemFn() throws Exception {        if(fnName.token.length()>=4&&Character.isUpperCase(fnName.token.charAt(3))) {            if (fnName.token.startsWith("set")) {                String assignVal = this.getCamelFnName("set");                String inputVal;                try {                    inputVal = arguments.get(0).argName.token;                } catch (Exception err) {                    throw fnName.throwError("Error: expect setter to have at least one argument");                }                return String.format("{\n    this.%s = %s;\n}", assignVal, inputVal);            } else if (fnName.token.startsWith("get"))                return String.format("{\n    return %s;\n}", this.getCamelFnName("get"));        }        switch (retType.token) {            case "int" -> {                return "{return 0;}";            }            case "String" -> {                return "{return \"\";}";            }            case "boolean" -> {                return "{return false;}";            }            default -> {                return "{;}";            }        }    }    public String export() throws Exception {        return String.format("%s %s(%s) %s", retType.token, fnName.token, this.exportArguments(), this.exportItemFn());    }}/** * Value * <br> * {@code typeName varName} */ class Value implements Exportable {    public Ident typeName;    public Ident varName;    public Value(PeekableTokenizer tokenizer) throws Exception {        this.typeName = tokenizer.next();        this.varName = tokenizer.next();        this.typeName.errReserved("typeName");        this.varName.errReserved("varName");    }    public String export() {        return String.format("%s %s", this.typeName.token, this.varName.token);    }}/** * Visibility * <br> * {@code +} */ enum Visibility {    Private,    Public} class IdentBuilder extends Span {    public StringBuilder token = new StringBuilder();    public IdentBuilder() {    }    public IdentBuilder(Span span) {        super(span.lineNo, span.start);    }    public void append(char c) {        token.append(c);    }    public Ident substring(int start, int end) {        return new Ident(this.lineNo, this.start + start, this.token.substring(start, end).replaceAll(Pattern.quote("#%$^"), "<|--"));    }    public Ident build() {        return new Ident(this, token.toString().replaceAll(Pattern.quote("#%$^"), "<|--"));    }    public Exception throwError(String msg) {        return new Exception(String.format("%s at %s", msg, this.getLocation()));    }    public boolean isEmpty() {        return this.token.isEmpty();    }    public int length() {        return this.token.length();    }} class PeekableReader {    private final Reader reader;    private char value = CharacterIterator.DONE;    public PeekableReader(Reader reader) {        this.reader = reader;        this.retrieveOne();    }    public PeekableReader(String content) {        this.reader = new StringReader(content);        this.retrieveOne();    }    private void retrieveOne() {        try {            this.value = (char) this.reader.read();        } catch (IOException e) {        }    }    public boolean hasNext() {        return value != CharacterIterator.DONE;    }    public char current() {        return value;    }    public char next() {        this.retrieveOne();        return value;    }} class Span {    protected int lineNo = 0;    protected int start = 0;    public Span() {    }    public Span(int lineNo, int start) {        this.lineNo = lineNo;        this.start = start;    }    public void nextLine() {        this.lineNo++;        this.start = 0;    }    public void nextCharacter() {        this.start++;    }    public void setLocationDelta(int delta) {        this.start += delta;    }    public String getLocation() {        return String.format("%d:%d", lineNo, start);    }    public Span clone() {        return new Span(lineNo, start);    }} class Tokenizer {    public static final CharacterIterator[] delimiters = {            new StringCharacterIterator("{"),            new StringCharacterIterator("}"),            new StringCharacterIterator("#%$^"),            new StringCharacterIterator("+"),            new StringCharacterIterator("-"),            new StringCharacterIterator("|"),            new StringCharacterIterator(":"),            new StringCharacterIterator("("),            new StringCharacterIterator(")"),            new StringCharacterIterator(","),    };    private static final char[] splitter = {'\t', '\n', ' '};    Queue<Ident> tokens = new LinkedList<>();    CharacterIterator[] progress = delimiters;    PeekableReader content;    IdentBuilder remain = new IdentBuilder();    public Tokenizer(String content) {        this.content = new PeekableReader(                content.replaceAll("<\\|--", Matcher.quoteReplacement("#%$^"))        );    }    public Tokenizer(Reader reader) {        this.content = new PeekableReader(reader);    }    /**     * Reset internal progress     */    private void resetProgress() {        this.progress = Tokenizer.delimiters;        this.remain = new IdentBuilder(this.remain);    }    /**     * Check splitter(character that should be removed, and also work as delimiter),     * add {@code current} to {@code remain} if it's not a splitter     *     * @param current character to check     */    private void checkSplitter(char current) {        if (current == '\n') remain.nextLine();        else remain.nextCharacter();        for (char c : Tokenizer.splitter) {            if (c == current) {                if (!this.remain.isEmpty()) tokens.add(this.remain.build());                this.resetProgress();                return;            }        }        this.remain.append(current);    }    /**     * poll tokens, and replace <code><|--</code> workaround, it returns null if empty     *     * @return token     */    private Ident checkToken() {        if (this.content.current() == CharacterIterator.DONE && this.remain != null) {            if (!this.remain.isEmpty()) tokens.add(this.remain.build());            remain = null;        }        if (tokens.isEmpty()) return null;        return tokens.remove();    }    /**     * Check for Delimiter(syntax-meaningful character, and also work as delimiter)     *     * @param current character to check     */    private void checkDelimiter(char current) {        for (CharacterIterator iter : this.progress) {            if (iter.current() != current) iter.first();            else if (iter.next() == CharacterIterator.DONE) {                int split = remain.length() - iter.getEndIndex();                if (split != 0) this.tokens.add(remain.substring(0, split));                this.tokens.add(remain.substring(split, remain.length()));                this.resetProgress();                return;            }        }    }    /**     * Attempt to check next token, return null if EOF     *     * @return next token     */    public Ident next() {        while (this.content.current() != CharacterIterator.DONE && this.tokens.isEmpty()) {            char current = this.content.current();            this.content.next();            this.checkSplitter(current);            if (!this.tokens.isEmpty()) break;            this.checkDelimiter(current);        }        return this.checkToken();    }} class PropertyList {    private final ArrayList<Property> args;    public PropertyList(ArrayList<Property> args) {        this.args = args;    }    public boolean contain(String typeName, String varName) {        for (Property arg : args)            if (arg.isValue() && (arg.value.typeName.token.equals(typeName) && arg.value.varName.token.equals(varName)))                return true;        return false;    }}